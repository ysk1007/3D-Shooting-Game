using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Photon.Pun;
using Unity.VisualScripting;
using InfimaGames.LowPolyShooterPack;
using Photon.Pun.Demo.PunBasics;


public class Bullet : MonoBehaviourPunCallbacks
{
    [Serializable]
    public struct BulletSetting
    {
        public WeaponName weaponName;   // 총알 이름
        public float bulletDamage;      // 총알 대미지
        public float criticalPercent;   // 치명타 배율
        public float bulletSpeed;       // 총알 속도
        public int bulletPenetration; // 총알 관통력
    }

    [SerializeField]
    BulletSetting bulletSetting;

    [SerializeField] private ParticleSystem ps;

    private Rigidbody rigidbody;
    private AudioSource audioSource;
    private BulletMemoryPool memoryPool;
    private MemoryPool bulletMemoryPool;
    private MemoryPool impactMemoryPool;
    private PhotonView photonView;

    private ParticleSystem.TriggerModule triggerModule;
    private List<ParticleSystem.Particle> particles;

    PlayerManager playerManager;
    
    private HashSet<GameObject> hitObjects = new HashSet<GameObject>(); // 이미 충돌한 객체를 저장
    int PenetrationCount;

    private void Awake()
    {
        rigidbody = GetComponent<Rigidbody>();
        photonView = GetComponent<PhotonView>();

        if (ps != null)
        {
            triggerModule = ps.trigger;

            // "Enemy" 태그가 있는 Collider와의 충돌을 감지하도록 설정
            triggerModule.SetCollider(0, GameObject.FindWithTag("EnemyFSM").GetComponent<Collider>());
        }
    }

    // 이동 방향 설정
    public void Setup(PlayerManager player, WeaponSetting weaponSetting, BulletMemoryPool BulletMemoryPool, MemoryPool bulletPool, MemoryPool impactPool, Transform parentTransform)
    {
        playerManager = player;
        bulletSetting.weaponName = weaponSetting.WeaponName;
        bulletSetting.bulletDamage = weaponSetting.damage * (1 + weaponSetting.weaponLevel);
        bulletSetting.bulletSpeed = weaponSetting.bulletSpeed;
        bulletSetting.criticalPercent = weaponSetting.critical;
        PenetrationCount = bulletSetting.bulletPenetration;
        hitObjects = new HashSet<GameObject>();

        memoryPool = BulletMemoryPool;
        bulletMemoryPool = bulletPool;
        impactMemoryPool = impactPool;

        gameObject.transform.SetParent(parentTransform);
        photonView.RPC("ActivateObjectRPC", RpcTarget.AllBuffered, true);
    }

    private void Update()
    {
        BulletMove();
    }

    // 충돌 감지
    void OnCollisionEnter(Collision collision)
    {
        bool critical = false;
        if (collision.transform.CompareTag("EnemyFSM"))
        {
            // 이미 충돌한 객체인지 확인
            if (hitObjects.Contains(collision.transform.parent.gameObject))
                return;

            hitObjects.Add(collision.transform.parent.gameObject); // 충돌한 객체 등록

            if (collision.gameObject.name == "Weakness") critical = true;

            float Damage = critical ? bulletSetting.bulletDamage * bulletSetting.criticalPercent : bulletSetting.bulletDamage;
            PenetrationCount--;

            if (collision.transform.GetComponentInParent<EnemyFSM>().TakeDamage(Damage))
            {
                // 충돌한 위치에 텍스트 생성
                DamageTextMemoryPool.instance.SpawnText(Damage, critical, transform.position);
                //playerManager.aimHitAnimator.SetTrigger("Show");
            }
        }
        else if (collision.transform.CompareTag("InteractionObject"))
        {
            collision.transform.GetComponent<InteractionObject>().TakeDamage(bulletSetting.bulletDamage);
        }
        else if (collision.transform.CompareTag("Shield"))
        {
            PenetrationCount--;
        }

        // 충돌한 위치에 이펙트 생성
        memoryPool?.SpawnImpact(bulletSetting.weaponName, transform.position, Quaternion.identity);

        if (PenetrationCount >= 0) return;
        // 총알 오브젝트 제거
        bulletMemoryPool?.DeactivatePoolItem(this.gameObject);
        photonView.RPC("ActivateObjectRPC", RpcTarget.AllBuffered, false);
    }

    // 트리거 충돌 감지
    void OnTriggerEnter(Collider other)
    {
        bool critical = false;
        if (other.transform.CompareTag("Enemy"))
        {
            // 이미 충돌한 객체인지 확인
            if (hitObjects.Contains(other.transform.parent.gameObject)) return;

            hitObjects.Add(other.transform.parent.gameObject); // 충돌한 객체 등록

            if (other.gameObject.name == "Weakness") critical = true;

            float Damage = critical ? bulletSetting.bulletDamage * bulletSetting.criticalPercent : bulletSetting.bulletDamage;
            PenetrationCount--;

            if (other.transform.GetComponentInParent<EnemyFSM>().TakeDamage(Damage))
            {
                // 충돌한 위치에 텍스트 생성
                DamageTextMemoryPool.instance.SpawnText(Damage, critical, transform.position);
                playerManager.aimHitAnimator.SetTrigger("Show");
            }
        }
        else if (other.transform.CompareTag("InteractionObject"))
        {
            other.transform.GetComponent<InteractionObject>().TakeDamage(bulletSetting.bulletDamage);
        }
        else if (other.transform.CompareTag("Shield"))
        {
            PenetrationCount--;
        }

        // 충돌한 위치에 이펙트 생성
        memoryPool?.SpawnImpact(bulletSetting.weaponName, transform.position, Quaternion.identity);

        if (PenetrationCount >= 0) return;
        // 총알 오브젝트 제거
        bulletMemoryPool?.DeactivatePoolItem(this.gameObject);
        photonView.RPC("ActivateObjectRPC", RpcTarget.AllBuffered, false);
    }

    void OnParticleTrigger()
    {
        if (particles == null || particles.Count < ps.main.maxParticles)
        {
            particles = new List<ParticleSystem.Particle>(ps.main.maxParticles);
        }

        int numEnter = ps.GetTriggerParticles(ParticleSystemTriggerEventType.Enter, particles);

        for (int i = 0; i < numEnter; i++)
        {
            Debug.Log("파티클이 Enemy와 충돌함!");
        }
    }

    private void OnParticleCollision(GameObject other)
    {
        Debug.Log("파티클 컬리전 충돌");
    }


    private void BulletMove()
    {
        rigidbody.velocity = transform.forward * bulletSetting.bulletSpeed;
    }

    // RPC를 통해 네트워크에서 비활성화 동기화
    [PunRPC]
    private void ActivateObjectRPC(bool isActive)
    {
        gameObject.SetActive(isActive);
    }
}
